name: GitOps Deploy reusable workflow

# Reusable workflow for deploying to a single environment via GitOps + ArgoCD
# Use with matrix strategy for multi-environment deployments

on:
  workflow_call:
    inputs:
      # Environment configuration
      environment:
        type: string
        description: Environment name (e.g., dev, spice, pjc)
        required: true
      namespace:
        type: string
        description: Kubernetes namespace
        required: true
      application:
        type: string
        description: Application name
        required: true
      
      # AWS configuration
      aws_account_id:
        type: string
        description: AWS Account ID
        required: true
      aws_region:
        type: string
        description: AWS Region
        default: 'us-east-1'
        required: false
      eks_cluster_name:
        type: string
        description: EKS Cluster name
        required: true
      github_oidc_role:
        type: string
        description: GitHub OIDC IAM role name
        default: 'github-oidc-provider-aws'
        required: false
      
      # ECR configuration
      ecr_repository:
        type: string
        description: ECR repository name
        required: true
      ecr_account_id:
        type: string
        description: ECR Account ID for images. If set, images are pushed/pulled from this account instead of aws_account_id. Can be shared ECR or any other account.
        required: false
        default: ''
      
      # Build configuration
      working_directory:
        type: string
        description: Working directory for build context
        default: '.'
        required: false
      docker_file:
        type: string
        description: Path to Dockerfile relative to working directory
        default: 'Dockerfile'
        required: false
      build_args:
        type: string
        description: Docker build arguments (e.g., APP_NAME=my-app)
        required: false
        default: ''
      
      # GitOps configuration
      gitops_repository:
        type: string
        description: GitOps repository (e.g., wearevolt/twenty-scripts-gitops)
        required: true
      gitops_branch:
        type: string
        description: GitOps repository branch
        default: 'main'
        required: false
      kustomize_path:
        type: string
        description: Path to kustomize overlay in GitOps repo
        required: true
      image_name:
        type: string
        description: Image name in kustomization.yaml (for kustomize edit set image)
        required: true
      
      # ArgoCD configuration
      argocd_app_name:
        type: string
        description: ArgoCD Application name
        required: true
      argocd_namespace:
        type: string
        description: ArgoCD namespace
        default: 'devtroncd'
        required: false
      argocd_sync_timeout:
        type: number
        description: ArgoCD sync timeout in seconds
        default: 300
        required: false
      argocd_app_manifest_path:
        type: string
        description: Path to ArgoCD Application manifest in GitOps repo (e.g., argocd/applications/app-dev.yaml)
        required: false
        default: ''
      
      # Optional: Skip verification (for faster deploys)
      skip_verification:
        type: boolean
        description: Skip ArgoCD sync verification
        default: false
        required: false
      
      # Optional: Custom image tag (e.g., semver tag like v1.0.0)
      image_tag:
        type: string
        description: Custom Docker image tag. If not provided, generates tag as {application}.{namespace}.{environment}.{sha}
        required: false
        default: ''
      
      # Optional: Skip build (for promotion/rollback using existing image)
      skip_build:
        type: boolean
        description: Skip Docker build and use existing image. Requires image_tag to be set. Use for promotion or rollback.
        default: false
        required: false

    outputs:
      image_tag:
        description: "Docker image tag used for deployment"
        value: ${{ jobs.build.outputs.image_tag || jobs.skip-build.outputs.image_tag }}
      deployment_status:
        description: "Deployment status (success/failed/skipped)"
        value: ${{ jobs.verify.outputs.status }}

jobs:
  # Job that runs when skip_build is false (default) - builds and pushes Docker image
  build:
    name: Build [${{ inputs.environment }}]
    if: ${{ inputs.skip_build == false }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.set-image-tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials for ECR
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          # Use ECR account if provided, otherwise use environment account
          role-to-assume: arn:aws:iam::${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}:role/${{ inputs.github_oidc_role }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Ensure ECR repository exists
        run: |
          REPO_NAME="${{ inputs.ecr_repository }}"
          if ! aws ecr describe-repositories --repository-names "$REPO_NAME" 2>/dev/null; then
            echo "Creating ECR repository '$REPO_NAME'..."
            aws ecr create-repository \
              --repository-name "$REPO_NAME" \
              --image-scanning-configuration scanOnPush=true
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Set image tag
        id: set-image-tag
        run: |
          if [ -n "${{ inputs.image_tag }}" ]; then
            # Use custom image tag if provided
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            # Generate default tag: {application}.{namespace}.{environment}.{sha}
            IMAGE_TAG="${{ inputs.application }}.${{ inputs.namespace }}.${{ inputs.environment }}.${{ github.sha }}"
          fi
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $IMAGE_TAG"
      
      - name: Build and push
        uses: docker/build-push-action@v5
        env:
          # Use ECR account if provided, otherwise use environment account
          ECR_ACCOUNT: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}
          ECR_REGISTRY: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
        with:
          context: ${{ inputs.working_directory }}
          file: ${{ inputs.working_directory }}/${{ inputs.docker_file }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ inputs.ecr_repository }}:${{ steps.set-image-tag.outputs.tag }}
          build-args: ${{ inputs.build_args }}
          secrets: |
            GIT_SSH_KEY=${{ secrets.GIT_SSH_KEY }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job that runs when skip_build is true - validates image exists and outputs tag
  skip-build:
    name: Skip Build (Promotion) [${{ inputs.environment }}]
    if: ${{ inputs.skip_build == true }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.validate.outputs.tag }}
    steps:
      - name: Validate inputs
        id: validate
        run: |
          if [ -z "${{ inputs.image_tag }}" ]; then
            echo "[ERROR] skip_build is true but image_tag is not provided!"
            echo "For promotion/rollback, you must specify the image_tag to deploy."
            exit 1
          fi
          echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "[OK] Using existing image tag: ${{ inputs.image_tag }}"
      
      - name: Configure AWS Credentials for ECR
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          role-to-assume: arn:aws:iam::${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}:role/${{ inputs.github_oidc_role }}
      
      - name: Verify image exists in ECR
        env:
          ECR_REGISTRY: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
          ECR_REPO: ${{ inputs.ecr_repository }}
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          echo "Verifying image exists: ${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          if aws ecr describe-images --repository-name "$ECR_REPO" --image-ids imageTag="$IMAGE_TAG" &>/dev/null; then
            echo "[OK] Image found in ECR"
          else
            echo "[ERROR] Image not found: ${ECR_REPO}:${IMAGE_TAG}"
            echo "Available tags:"
            aws ecr describe-images --repository-name "$ECR_REPO" --query 'imageDetails[*].imageTags' --output text | tr '\t' '\n' | sort -V | tail -10
            exit 1
          fi

  update-gitops:
    name: Update GitOps [${{ inputs.environment }}]
    needs: [build, skip-build]
    if: ${{ always() && (needs.build.result == 'success' || needs.skip-build.result == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout GitOps Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.gitops_repository }}
          token: ${{ secrets.GITOPS_PAT }}
          ref: ${{ inputs.gitops_branch }}
          path: gitops

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Images with Kustomize
        working-directory: gitops/${{ inputs.kustomize_path }}
        env:
          # Use ECR account if provided, otherwise use environment account
          ECR_REGISTRY: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
          ECR_REPO: ${{ inputs.ecr_repository }}
          # Use image_tag from whichever job ran (build or skip-build)
          IMAGE_TAG: ${{ needs.build.outputs.image_tag || needs.skip-build.outputs.image_tag }}
          IMAGE_NAME: ${{ inputs.image_name }}
        run: |
          kustomize edit set image ${IMAGE_NAME}=${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}
          echo "Updated image to: ${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          
      - name: Commit and Push
        uses: stefanzweifel/git-auto-commit-action@v5
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image_tag || needs.skip-build.outputs.image_tag }}
        with:
          repository: gitops
          commit_message: "chore(deploy): [${{ inputs.environment }}] update ${{ inputs.application }} to ${{ env.IMAGE_TAG }}"
          branch: ${{ inputs.gitops_branch }}
          file_pattern: .

  verify:
    name: Verify [${{ inputs.environment }}]
    needs: [build, skip-build, update-gitops]
    if: ${{ always() && needs.update-gitops.result == 'success' && inputs.skip_verification == false }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          role-to-assume: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.github_oidc_role }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ inputs.eks_cluster_name }} \
            --region ${{ inputs.aws_region }}

      - name: Checkout GitOps Repo (for ArgoCD manifest)
        if: ${{ inputs.argocd_app_manifest_path != '' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.gitops_repository }}
          token: ${{ secrets.GITOPS_PAT }}
          ref: ${{ inputs.gitops_branch }}
          path: gitops

      - name: Ensure ArgoCD Application exists
        if: ${{ inputs.argocd_app_manifest_path != '' }}
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          MANIFEST_PATH: ${{ inputs.argocd_app_manifest_path }}
          EKS_CLUSTER: ${{ inputs.eks_cluster_name }}
          AWS_REGION: ${{ inputs.aws_region }}
        run: |
          # Re-update kubeconfig (checkout may affect HOME)
          aws eks update-kubeconfig --name "$EKS_CLUSTER" --region "$AWS_REGION"
          
          # Debug: check current identity
          echo "=== AWS Identity ==="
          aws sts get-caller-identity
          
          # Debug: test kubectl access
          echo "=== Testing kubectl access ==="
          kubectl get nodes --request-timeout=10s || echo "[WARN] Cannot list nodes"
          
          if kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" &>/dev/null; then
            echo "[OK] ArgoCD Application '$ARGOCD_APP' already exists"
          else
            echo "[INFO] ArgoCD Application '$ARGOCD_APP' not found, creating..."
            kubectl apply -f "gitops/$MANIFEST_PATH" --validate=false
            echo "[OK] ArgoCD Application created"
            # Give ArgoCD a moment to register the new application
            sleep 5
          fi

      - name: Wait for ArgoCD sync
        id: wait-sync
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          EXPECTED_TAG: ${{ needs.build.outputs.image_tag || needs.skip-build.outputs.image_tag }}
          NAMESPACE: ${{ inputs.namespace }}
          TIMEOUT: ${{ inputs.argocd_sync_timeout }}
        run: |
          echo "=== Waiting for ArgoCD application '$ARGOCD_APP' to sync ==="
          echo "Expected image tag: $EXPECTED_TAG"

          start_time=$(date +%s)
          while true; do
            # Check ArgoCD sync and health status
            STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")

            # Check actual deployed image tag in the namespace
            CURRENT_IMAGE=$(kubectl get deployment -n "$NAMESPACE" -o jsonpath='{.items[0].spec.template.spec.containers[0].image}' 2>/dev/null || echo "")
            CURRENT_TAG=$(echo "$CURRENT_IMAGE" | grep -oP ':[^:]+$' | cut -d: -f2)

            echo "Sync: $STATUS | Health: $HEALTH | Current tag: ${CURRENT_TAG:-none}"

            # Success if synced AND healthy AND correct image deployed
            if [[ "$STATUS" == "Synced" && "$HEALTH" == "Healthy" && "$CURRENT_TAG" == "$EXPECTED_TAG" ]]; then
              echo "[OK] Application is synced, healthy, and has correct image!"
              echo "synced=true" >> $GITHUB_OUTPUT
              break
            fi

            # Also accept if image matches and health is good, even if sync status is temporarily Unknown
            # This handles re-runs where the image tag hasn't changed
            if [[ "$HEALTH" == "Healthy" && "$CURRENT_TAG" == "$EXPECTED_TAG" ]]; then
              echo "[OK] Application is healthy with correct image (sync status: $STATUS)"
              echo "synced=true" >> $GITHUB_OUTPUT
              break
            fi

            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            if [[ $elapsed -ge $TIMEOUT ]]; then
              echo "[ERROR] Timeout waiting for application to sync"
              echo "Status: $STATUS | Health: $HEALTH"
              echo "Expected tag: $EXPECTED_TAG | Current tag: ${CURRENT_TAG:-none}"
              echo "synced=false" >> $GITHUB_OUTPUT
              exit 1
            fi

            sleep 10
          done

      - name: Set status
        id: set-status
        if: always()
        run: |
          if [ "${{ steps.wait-sync.outputs.synced }}" == "true" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Deployment Summary
        if: always()
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          NAMESPACE: ${{ inputs.namespace }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          echo "## Deployment Summary [$ENVIRONMENT]" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ inputs.application }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: $NAMESPACE" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.build.outputs.image_tag || needs.skip-build.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Mode**: ${{ inputs.skip_build && 'Promotion/Rollback' || 'Build & Deploy' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          SYNC_STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "### ArgoCD Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Sync**: $SYNC_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Health**: $HEALTH_STATUS" >> $GITHUB_STEP_SUMMARY

