name: GitOps Deploy reusable workflow

# Reusable workflow for deploying to a single environment via GitOps + ArgoCD
# Use with matrix strategy for multi-environment deployments

on:
  workflow_call:
    inputs:
      # Environment configuration
      environment:
        type: string
        description: Environment name (e.g., dev, spice, pjc)
        required: true
      namespace:
        type: string
        description: Kubernetes namespace
        required: true
      application:
        type: string
        description: Application name
        required: true
      
      # AWS configuration
      aws_account_id:
        type: string
        description: AWS Account ID
        required: true
      aws_region:
        type: string
        description: AWS Region
        default: 'us-east-1'
        required: false
      eks_cluster_name:
        type: string
        description: EKS Cluster name
        required: true
      github_oidc_role:
        type: string
        description: GitHub OIDC IAM role name
        default: 'github-oidc-provider-aws'
        required: false
      
      # ECR configuration
      ecr_repository:
        type: string
        description: ECR repository name
        required: true
      ecr_account_id:
        type: string
        description: ECR Account ID for images. If set, images are pushed/pulled from this account instead of aws_account_id. Can be shared ECR or any other account.
        required: false
        default: ''
      
      # Build configuration
      working_directory:
        type: string
        description: Working directory for build context
        default: '.'
        required: false
      docker_file:
        type: string
        description: Path to Dockerfile relative to working directory
        default: 'Dockerfile'
        required: false
      build_args:
        type: string
        description: Docker build arguments (e.g., APP_NAME=my-app)
        required: false
        default: ''
      
      # GitOps configuration
      gitops_repository:
        type: string
        description: GitOps repository (e.g., wearevolt/twenty-scripts-gitops)
        required: true
      gitops_branch:
        type: string
        description: GitOps repository branch
        default: 'main'
        required: false
      values_path:
        type: string
        description: Path to values directory in GitOps repo (e.g., apps/llm-agent/qa)
        required: true
      values_file:
        type: string
        description: Values file name
        default: 'values.yaml'
        required: false
      image_key:
        type: string
        description: YAML key path for image in values file (e.g., "llm-agent-web-worker.IMAGE")
        required: true
      
      # ArgoCD configuration
      argocd_app_name:
        type: string
        description: ArgoCD Application name
        required: true
      argocd_namespace:
        type: string
        description: ArgoCD namespace
        default: 'devtroncd'
        required: false
      argocd_sync_timeout:
        type: number
        description: ArgoCD sync timeout in seconds
        default: 300
        required: false
      argocd_app_manifest_path:
        type: string
        description: Path to ArgoCD Application manifest in GitOps repo (e.g., argocd/applications/app-dev.yaml)
        required: false
        default: ''
      
      # Optional: Skip verification (for faster deploys)
      skip_verification:
        type: boolean
        description: Skip ArgoCD sync verification
        default: false
        required: false

    outputs:
      image_tag:
        description: "Built Docker image tag"
        value: ${{ jobs.build.outputs.image_tag }}
      deployment_status:
        description: "Deployment status (success/failed/skipped)"
        value: ${{ jobs.verify.outputs.status }}

jobs:
  build:
    name: Build [${{ inputs.environment }}]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.set-image-tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials for ECR
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          # Use ECR account if provided, otherwise use environment account
          role-to-assume: arn:aws:iam::${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}:role/${{ inputs.github_oidc_role }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Ensure ECR repository exists
        run: |
          REPO_NAME="${{ inputs.ecr_repository }}"
          if ! aws ecr describe-repositories --repository-names "$REPO_NAME" 2>/dev/null; then
            echo "Creating ECR repository '$REPO_NAME'..."
            aws ecr create-repository \
              --repository-name "$REPO_NAME" \
              --image-scanning-configuration scanOnPush=true
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Set image tag
        id: set-image-tag
        run: |
          IMAGE_TAG="${{ inputs.application }}.${{ inputs.namespace }}.${{ inputs.environment }}.${{ github.sha }}"
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
      
      - name: Build and push
        uses: docker/build-push-action@v5
        env:
          # Use ECR account if provided, otherwise use environment account
          ECR_ACCOUNT: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}
          ECR_REGISTRY: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
        with:
          context: ${{ inputs.working_directory }}
          file: ${{ inputs.working_directory }}/${{ inputs.docker_file }}
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ inputs.ecr_repository }}:${{ steps.set-image-tag.outputs.tag }}
          build-args: ${{ inputs.build_args }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  update-gitops:
    name: Update GitOps [${{ inputs.environment }}]
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout GitOps Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.gitops_repository }}
          token: ${{ secrets.GITOPS_PAT }}
          ref: ${{ inputs.gitops_branch }}
          path: gitops

      - name: Update image in values.yaml with yq
        working-directory: gitops/${{ inputs.values_path }}
        env:
          # Use ECR account if provided, otherwise use environment account
          ECR_REGISTRY: ${{ inputs.ecr_account_id != '' && inputs.ecr_account_id || inputs.aws_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
          ECR_REPO: ${{ inputs.ecr_repository }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          VALUES_FILE: ${{ inputs.values_file }}
          IMAGE_KEY: ${{ inputs.image_key }}
        run: |
          # Install yq if not available
          if ! command -v yq &> /dev/null; then
            echo "Installing yq..."
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
          
          IMAGE_URL="${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          echo "Updating image in $VALUES_FILE at key: $IMAGE_KEY"
          echo "New image: $IMAGE_URL"
          
          # Update or add image field in values.yaml
          yq eval -i ".$IMAGE_KEY = \"$IMAGE_URL\"" "$VALUES_FILE"
          
          echo "Updated $VALUES_FILE"
          
      - name: Commit and Push
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          repository: gitops
          commit_message: "chore(deploy): [${{ inputs.environment }}] update ${{ inputs.application }} to ${{ needs.build.outputs.image_tag }}"
          branch: ${{ inputs.gitops_branch }}
          file_pattern: ${{ inputs.values_path }}/${{ inputs.values_file }}

  verify:
    name: Verify [${{ inputs.environment }}]
    needs: [build, update-gitops]
    if: ${{ inputs.skip_verification == false }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          role-to-assume: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.github_oidc_role }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ inputs.eks_cluster_name }} \
            --region ${{ inputs.aws_region }}

      - name: Checkout GitOps Repo (for ArgoCD manifest)
        if: ${{ inputs.argocd_app_manifest_path != '' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.gitops_repository }}
          token: ${{ secrets.GITOPS_PAT }}
          ref: ${{ inputs.gitops_branch }}
          path: gitops

      - name: Ensure ArgoCD Application exists
        if: ${{ inputs.argocd_app_manifest_path != '' }}
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          MANIFEST_PATH: ${{ inputs.argocd_app_manifest_path }}
          EKS_CLUSTER: ${{ inputs.eks_cluster_name }}
          AWS_REGION: ${{ inputs.aws_region }}
        run: |
          # Re-update kubeconfig (checkout may affect HOME)
          aws eks update-kubeconfig --name "$EKS_CLUSTER" --region "$AWS_REGION"
          
          # Debug: check current identity
          echo "=== AWS Identity ==="
          aws sts get-caller-identity
          
          # Debug: test kubectl access
          echo "=== Testing kubectl access ==="
          kubectl get nodes --request-timeout=10s || echo "[WARN] Cannot list nodes"
          
          if kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" &>/dev/null; then
            echo "[OK] ArgoCD Application '$ARGOCD_APP' already exists"
          else
            echo "[INFO] ArgoCD Application '$ARGOCD_APP' not found, creating..."
            kubectl apply -f "gitops/$MANIFEST_PATH" --validate=false
            echo "[OK] ArgoCD Application created"
            # Give ArgoCD a moment to register the new application
            sleep 5
          fi

      - name: Wait for ArgoCD sync
        id: wait-sync
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          TIMEOUT: ${{ inputs.argocd_sync_timeout }}
        run: |
          echo "=== Waiting for ArgoCD application '$ARGOCD_APP' to sync ==="
          
          start_time=$(date +%s)
          while true; do
            STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            echo "Sync: $STATUS | Health: $HEALTH"
            
            if [[ "$STATUS" == "Synced" && "$HEALTH" == "Healthy" ]]; then
              echo "[OK] Application is synced and healthy!"
              echo "synced=true" >> $GITHUB_OUTPUT
              break
            fi
            
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            if [[ $elapsed -ge $TIMEOUT ]]; then
              echo "[ERROR] Timeout waiting for application to sync"
              echo "synced=false" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            sleep 10
          done

      - name: Set status
        id: set-status
        if: always()
        run: |
          if [ "${{ steps.wait-sync.outputs.synced }}" == "true" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Deployment Summary
        if: always()
        env:
          ARGOCD_APP: ${{ inputs.argocd_app_name }}
          ARGOCD_NS: ${{ inputs.argocd_namespace }}
          NAMESPACE: ${{ inputs.namespace }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          echo "## Deployment Summary [$ENVIRONMENT]" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ inputs.application }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: $NAMESPACE" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.build.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          SYNC_STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application "$ARGOCD_APP" -n "$ARGOCD_NS" -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "### ArgoCD Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Sync**: $SYNC_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Health**: $HEALTH_STATUS" >> $GITHUB_STEP_SUMMARY

